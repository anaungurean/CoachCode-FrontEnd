import {
  VERSION,
  arraify,
  build,
  buildErrorMessage,
  createFilter,
  createLogger,
  createServer,
  defineConfig,
  fetchModule,
  formatPostcssSourceMap,
  isFileServingAllowed,
  isInNodeModules$1,
  loadConfigFromFile,
  loadEnv,
  mergeAlias,
  mergeConfig,
  normalizePath$3,
  optimizeDeps,
  preprocessCSS,
  preview,
  require_assert,
  require_buffer,
  require_child_process,
  require_crypto,
  require_http,
  require_https,
  require_main,
  require_module,
  require_net,
  require_node_assert,
  require_node_buffer,
  require_node_child_process,
  require_node_crypto,
  require_node_dns,
  require_node_events,
  require_node_readline,
  require_node_util,
  require_node_v8,
  require_node_worker_threads,
  require_node_zlib,
  require_querystring,
  require_tls,
  require_zlib,
  resolveConfig,
  resolveEnvPrefix,
  rollupVersion,
  searchForWorkspaceRoot,
  send,
  sortUserPlugins,
  transformWithEsbuild
} from "./chunk-7JCMDJCW.js";
import {
  require_events,
  require_node_os,
  require_os,
  require_stream,
  require_util
} from "./chunk-QYH7EYKV.js";
import {
  parseAst,
  parseAstAsync,
  require_node_fs,
  require_node_perf_hooks,
  require_promises,
  require_tty
} from "./chunk-2EOUDYVB.js";
import {
  require_node_http
} from "./chunk-LBVRQKET.js";
import {
  require_node_https
} from "./chunk-VGEDKR3Q.js";
import {
  require_node_module,
  require_node_url
} from "./chunk-AMUFGQUD.js";
import {
  require_node_path
} from "./chunk-DC5P2332.js";
import {
  require_url
} from "./chunk-SYXRNMS6.js";
import {
  require_fs
} from "./chunk-7B2Y2JNU.js";
import {
  require_path
} from "./chunk-OAT74JD6.js";
import {
  ESModulesRunner,
  ViteRuntime
} from "./chunk-W3TQS6UT.js";
import {
  __publicField,
  __toESM
} from "./chunk-L5ZTYQEE.js";

// node_modules/vite/dist/node/index.js
var import_esbuild = __toESM(require_main());
var import_node_fs = __toESM(require_node_fs());
var import_promises = __toESM(require_promises());
var import_node_path = __toESM(require_node_path());
var import_node_url = __toESM(require_node_url());
var import_node_util = __toESM(require_node_util());
var import_node_perf_hooks = __toESM(require_node_perf_hooks());
var import_node_module = __toESM(require_node_module());
var import_tty = __toESM(require_tty());
var import_path = __toESM(require_path());
var import_fs = __toESM(require_fs());
var import_events = __toESM(require_events());
var import_assert = __toESM(require_assert());
var import_node_child_process = __toESM(require_node_child_process());
var import_node_http = __toESM(require_node_http());
var import_node_https = __toESM(require_node_https());
var import_util = __toESM(require_util());
var import_net = __toESM(require_net());
var import_url = __toESM(require_url());
var import_http = __toESM(require_http());
var import_stream = __toESM(require_stream());
var import_os = __toESM(require_os());
var import_child_process = __toESM(require_child_process());
var import_node_os = __toESM(require_node_os());
var import_node_crypto = __toESM(require_node_crypto());
var import_node_dns = __toESM(require_node_dns());
var import_crypto = __toESM(require_crypto());
var import_module = __toESM(require_module());
var import_node_assert = __toESM(require_node_assert());
var import_node_v8 = __toESM(require_node_v8());
var import_node_worker_threads = __toESM(require_node_worker_threads());
var import_node_buffer = __toESM(require_node_buffer());
var import_node_events = __toESM(require_node_events());
var import_querystring = __toESM(require_querystring());
var import_node_readline = __toESM(require_node_readline());
var import_zlib = __toESM(require_zlib());
var import_buffer = __toESM(require_buffer());
var import_https = __toESM(require_https());
var import_tls = __toESM(require_tls());
var import_node_zlib = __toESM(require_node_zlib());
var CSS_LANGS_RE = (
  // eslint-disable-next-line regexp/no-unused-capturing-group
  /\.(css|less|sass|scss|styl|stylus|pcss|postcss|sss)(?:$|\?)/
);
var isCSSRequest = (request) => CSS_LANGS_RE.test(request);
var SplitVendorChunkCache = class {
  constructor() {
    __publicField(this, "cache");
    this.cache = /* @__PURE__ */ new Map();
  }
  reset() {
    this.cache = /* @__PURE__ */ new Map();
  }
};
function splitVendorChunk(options = {}) {
  const cache = options.cache ?? new SplitVendorChunkCache();
  return (id, { getModuleInfo }) => {
    if (isInNodeModules$1(id) && !isCSSRequest(id) && staticImportedByEntry(id, getModuleInfo, cache.cache)) {
      return "vendor";
    }
  };
}
function staticImportedByEntry(id, getModuleInfo, cache, importStack = []) {
  if (cache.has(id)) {
    return cache.get(id);
  }
  if (importStack.includes(id)) {
    cache.set(id, false);
    return false;
  }
  const mod = getModuleInfo(id);
  if (!mod) {
    cache.set(id, false);
    return false;
  }
  if (mod.isEntry) {
    cache.set(id, true);
    return true;
  }
  const someImporterIs = mod.importers.some((importer) => staticImportedByEntry(importer, getModuleInfo, cache, importStack.concat(id)));
  cache.set(id, someImporterIs);
  return someImporterIs;
}
function splitVendorChunkPlugin() {
  const caches = [];
  function createSplitVendorChunk(output, config) {
    const cache = new SplitVendorChunkCache();
    caches.push(cache);
    const build2 = config.build ?? {};
    const format = output == null ? void 0 : output.format;
    if (!build2.ssr && !build2.lib && format !== "umd" && format !== "iife") {
      return splitVendorChunk({ cache });
    }
  }
  return {
    name: "vite:split-vendor-chunk",
    config(config) {
      var _a, _b;
      let outputs = (_b = (_a = config == null ? void 0 : config.build) == null ? void 0 : _a.rollupOptions) == null ? void 0 : _b.output;
      if (outputs) {
        outputs = arraify(outputs);
        for (const output of outputs) {
          const viteManualChunks = createSplitVendorChunk(output, config);
          if (viteManualChunks) {
            if (output.manualChunks) {
              if (typeof output.manualChunks === "function") {
                const userManualChunks = output.manualChunks;
                output.manualChunks = (id, api) => {
                  return userManualChunks(id, api) ?? viteManualChunks(id, api);
                };
              } else {
                console.warn("(!) the `splitVendorChunk` plugin doesn't have any effect when using the object form of `build.rollupOptions.output.manualChunks`. Consider using the function form instead.");
              }
            } else {
              output.manualChunks = viteManualChunks;
            }
          }
        }
      } else {
        return {
          build: {
            rollupOptions: {
              output: {
                manualChunks: createSplitVendorChunk({}, config)
              }
            }
          }
        };
      }
    },
    buildStart() {
      caches.forEach((cache) => cache.reset());
    }
  };
}
var ServerHMRBroadcasterClient = class {
  constructor(hmrChannel) {
    __publicField(this, "hmrChannel");
    this.hmrChannel = hmrChannel;
  }
  send(...args) {
    let payload;
    if (typeof args[0] === "string") {
      payload = {
        type: "custom",
        event: args[0],
        data: args[1]
      };
    } else {
      payload = args[0];
    }
    if (payload.type !== "custom") {
      throw new Error("Cannot send non-custom events from the client to the server.");
    }
    this.hmrChannel.send(payload);
  }
};
var ServerHMRConnector = class {
  constructor(server) {
    __publicField(this, "handlers", []);
    __publicField(this, "hmrChannel");
    __publicField(this, "hmrClient");
    __publicField(this, "connected", false);
    var _a;
    const hmrChannel = (_a = server.hot) == null ? void 0 : _a.channels.find((c) => c.name === "ssr");
    if (!hmrChannel) {
      throw new Error("Your version of Vite doesn't support HMR during SSR. Please, use Vite 5.1 or higher.");
    }
    this.hmrClient = new ServerHMRBroadcasterClient(hmrChannel);
    hmrChannel.api.outsideEmitter.on("send", (payload) => {
      this.handlers.forEach((listener) => listener(payload));
    });
    this.hmrChannel = hmrChannel;
  }
  isReady() {
    return this.connected;
  }
  send(message) {
    const payload = JSON.parse(message);
    this.hmrChannel.api.innerEmitter.emit(payload.event, payload.data, this.hmrClient);
  }
  onUpdate(handler) {
    this.handlers.push(handler);
    handler({ type: "connected" });
    this.connected = true;
  }
};
function createHMROptions(server, options) {
  var _a;
  if (server.config.server.hmr === false || options.hmr === false) {
    return false;
  }
  const connection = new ServerHMRConnector(server);
  return {
    connection,
    logger: (_a = options.hmr) == null ? void 0 : _a.logger
  };
}
var prepareStackTrace = {
  retrieveFile(id) {
    if ((0, import_node_fs.existsSync)(id)) {
      return (0, import_node_fs.readFileSync)(id, "utf-8");
    }
  }
};
function resolveSourceMapOptions(options) {
  if (options.sourcemapInterceptor != null) {
    if (options.sourcemapInterceptor === "prepareStackTrace") {
      return prepareStackTrace;
    }
    if (typeof options.sourcemapInterceptor === "object") {
      return { ...prepareStackTrace, ...options.sourcemapInterceptor };
    }
    return options.sourcemapInterceptor;
  }
  if (typeof process !== "undefined" && "setSourceMapsEnabled" in process) {
    return "node";
  }
  return prepareStackTrace;
}
async function createViteRuntime(server, options = {}) {
  const hmr = createHMROptions(server, options);
  return new ViteRuntime({
    ...options,
    root: server.config.root,
    fetchModule: server.ssrFetchModule,
    hmr,
    sourcemapInterceptor: resolveSourceMapOptions(options)
  }, options.runner || new ESModulesRunner());
}
var export_esbuildVersion = import_esbuild.version;
export {
  ServerHMRConnector,
  build,
  buildErrorMessage,
  createFilter,
  createLogger,
  createServer,
  createViteRuntime,
  defineConfig,
  export_esbuildVersion as esbuildVersion,
  fetchModule,
  formatPostcssSourceMap,
  isCSSRequest,
  isFileServingAllowed,
  loadConfigFromFile,
  loadEnv,
  mergeAlias,
  mergeConfig,
  normalizePath$3 as normalizePath,
  optimizeDeps,
  parseAst,
  parseAstAsync,
  preprocessCSS,
  preview,
  resolveConfig,
  resolveEnvPrefix,
  rollupVersion,
  searchForWorkspaceRoot,
  send,
  sortUserPlugins,
  splitVendorChunk,
  splitVendorChunkPlugin,
  transformWithEsbuild,
  VERSION as version
};
//# sourceMappingURL=vite.js.map
