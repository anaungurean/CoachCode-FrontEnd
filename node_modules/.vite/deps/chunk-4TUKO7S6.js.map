{
  "version": 3,
  "sources": ["browser-external:source-map-js", "../../postcss/lib/previous-map.js"],
  "sourcesContent": ["module.exports = Object.create(new Proxy({}, {\n  get(_, key) {\n    if (\n      key !== '__esModule' &&\n      key !== '__proto__' &&\n      key !== 'constructor' &&\n      key !== 'splice'\n    ) {\n      console.warn(`Module \"source-map-js\" has been externalized for browser compatibility. Cannot access \"source-map-js.${key}\" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`)\n    }\n  }\n}))", "'use strict'\r\n\r\nlet { SourceMapConsumer, SourceMapGenerator } = require('source-map-js')\r\nlet { existsSync, readFileSync } = require('fs')\r\nlet { dirname, join } = require('path')\r\n\r\nfunction fromBase64(str) {\r\n  if (Buffer) {\r\n    return Buffer.from(str, 'base64').toString()\r\n  } else {\r\n    /* c8 ignore next 2 */\r\n    return window.atob(str)\r\n  }\r\n}\r\n\r\nclass PreviousMap {\r\n  constructor(css, opts) {\r\n    if (opts.map === false) return\r\n    this.loadAnnotation(css)\r\n    this.inline = this.startWith(this.annotation, 'data:')\r\n\r\n    let prev = opts.map ? opts.map.prev : undefined\r\n    let text = this.loadMap(opts.from, prev)\r\n    if (!this.mapFile && opts.from) {\r\n      this.mapFile = opts.from\r\n    }\r\n    if (this.mapFile) this.root = dirname(this.mapFile)\r\n    if (text) this.text = text\r\n  }\r\n\r\n  consumer() {\r\n    if (!this.consumerCache) {\r\n      this.consumerCache = new SourceMapConsumer(this.text)\r\n    }\r\n    return this.consumerCache\r\n  }\r\n\r\n  decodeInline(text) {\r\n    let baseCharsetUri = /^data:application\\/json;charset=utf-?8;base64,/\r\n    let baseUri = /^data:application\\/json;base64,/\r\n    let charsetUri = /^data:application\\/json;charset=utf-?8,/\r\n    let uri = /^data:application\\/json,/\r\n\r\n    if (charsetUri.test(text) || uri.test(text)) {\r\n      return decodeURIComponent(text.substr(RegExp.lastMatch.length))\r\n    }\r\n\r\n    if (baseCharsetUri.test(text) || baseUri.test(text)) {\r\n      return fromBase64(text.substr(RegExp.lastMatch.length))\r\n    }\r\n\r\n    let encoding = text.match(/data:application\\/json;([^,]+),/)[1]\r\n    throw new Error('Unsupported source map encoding ' + encoding)\r\n  }\r\n\r\n  getAnnotationURL(sourceMapString) {\r\n    return sourceMapString.replace(/^\\/\\*\\s*# sourceMappingURL=/, '').trim()\r\n  }\r\n\r\n  isMap(map) {\r\n    if (typeof map !== 'object') return false\r\n    return (\r\n      typeof map.mappings === 'string' ||\r\n      typeof map._mappings === 'string' ||\r\n      Array.isArray(map.sections)\r\n    )\r\n  }\r\n\r\n  loadAnnotation(css) {\r\n    let comments = css.match(/\\/\\*\\s*# sourceMappingURL=/gm)\r\n    if (!comments) return\r\n\r\n    // sourceMappingURLs from comments, strings, etc.\r\n    let start = css.lastIndexOf(comments.pop())\r\n    let end = css.indexOf('*/', start)\r\n\r\n    if (start > -1 && end > -1) {\r\n      // Locate the last sourceMappingURL to avoid pickin\r\n      this.annotation = this.getAnnotationURL(css.substring(start, end))\r\n    }\r\n  }\r\n\r\n  loadFile(path) {\r\n    this.root = dirname(path)\r\n    if (existsSync(path)) {\r\n      this.mapFile = path\r\n      return readFileSync(path, 'utf-8').toString().trim()\r\n    }\r\n  }\r\n\r\n  loadMap(file, prev) {\r\n    if (prev === false) return false\r\n\r\n    if (prev) {\r\n      if (typeof prev === 'string') {\r\n        return prev\r\n      } else if (typeof prev === 'function') {\r\n        let prevPath = prev(file)\r\n        if (prevPath) {\r\n          let map = this.loadFile(prevPath)\r\n          if (!map) {\r\n            throw new Error(\r\n              'Unable to load previous source map: ' + prevPath.toString()\r\n            )\r\n          }\r\n          return map\r\n        }\r\n      } else if (prev instanceof SourceMapConsumer) {\r\n        return SourceMapGenerator.fromSourceMap(prev).toString()\r\n      } else if (prev instanceof SourceMapGenerator) {\r\n        return prev.toString()\r\n      } else if (this.isMap(prev)) {\r\n        return JSON.stringify(prev)\r\n      } else {\r\n        throw new Error(\r\n          'Unsupported previous source map format: ' + prev.toString()\r\n        )\r\n      }\r\n    } else if (this.inline) {\r\n      return this.decodeInline(this.annotation)\r\n    } else if (this.annotation) {\r\n      let map = this.annotation\r\n      if (file) map = join(dirname(file), map)\r\n      return this.loadFile(map)\r\n    }\r\n  }\r\n\r\n  startWith(string, start) {\r\n    if (!string) return false\r\n    return string.substr(0, start.length) === start\r\n  }\r\n\r\n  withContent() {\r\n    return !!(\r\n      this.consumer().sourcesContent &&\r\n      this.consumer().sourcesContent.length > 0\r\n    )\r\n  }\r\n}\r\n\r\nmodule.exports = PreviousMap\r\nPreviousMap.default = PreviousMap\r\n"],
  "mappings": "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",
  "names": []
}
