{
  "version": 3,
  "sources": ["../../vite/dist/node/chunks/dep-yOtoFZYM.js"],
  "sourcesContent": ["import { B as getDefaultExportFromCjs } from './dep-BBHrJRja.js';\r\nimport require$$0 from 'path';\r\nimport require$$0__default from 'fs';\r\nimport { l as lib } from './dep-IQS-Za7F.js';\r\n\r\nimport { fileURLToPath as __cjs_fileURLToPath } from 'node:url';\r\nimport { dirname as __cjs_dirname } from 'node:path';\r\nimport { createRequire as __cjs_createRequire } from 'node:module';\r\n\r\nconst __filename = __cjs_fileURLToPath(import.meta.url);\r\nconst __dirname = __cjs_dirname(__filename);\r\nconst require = __cjs_createRequire(import.meta.url);\r\nconst __require = require;\r\nfunction _mergeNamespaces(n, m) {\r\n  for (var i = 0; i < m.length; i++) {\r\n    var e = m[i];\r\n    if (typeof e !== 'string' && !Array.isArray(e)) { for (var k in e) {\r\n      if (k !== 'default' && !(k in n)) {\r\n        n[k] = e[k];\r\n      }\r\n    } }\r\n  }\r\n  return n;\r\n}\r\n\r\nvar formatImportPrelude$2 = function formatImportPrelude(layer, media, supports) {\r\n  const parts = [];\r\n\r\n  if (typeof layer !== \"undefined\") {\r\n    let layerParams = \"layer\";\r\n    if (layer) {\r\n      layerParams = `layer(${layer})`;\r\n    }\r\n\r\n    parts.push(layerParams);\r\n  }\r\n\r\n  if (typeof supports !== \"undefined\") {\r\n    parts.push(`supports(${supports})`);\r\n  }\r\n\r\n  if (typeof media !== \"undefined\") {\r\n    parts.push(media);\r\n  }\r\n\r\n  return parts.join(\" \")\r\n};\r\n\r\nconst formatImportPrelude$1 = formatImportPrelude$2;\r\n\r\n// Base64 encode an import with conditions\r\n// The order of conditions is important and is interleaved with cascade layer declarations\r\n// Each group of conditions and cascade layers needs to be interpreted in order\r\n// To achieve this we create a list of base64 encoded imports, where each import contains a stylesheet with another import.\r\n// Each import can define a single group of conditions and a single cascade layer.\r\nvar base64EncodedImport = function base64EncodedConditionalImport(prelude, conditions) {\r\n  conditions.reverse();\r\n  const first = conditions.pop();\r\n  let params = `${prelude} ${formatImportPrelude$1(\r\n    first.layer,\r\n    first.media,\r\n    first.supports,\r\n  )}`;\r\n\r\n  for (const condition of conditions) {\r\n    params = `'data:text/css;base64,${Buffer.from(`@import ${params}`).toString(\r\n      \"base64\",\r\n    )}' ${formatImportPrelude$1(\r\n      condition.layer,\r\n      condition.media,\r\n      condition.supports,\r\n    )}`;\r\n  }\r\n\r\n  return params\r\n};\r\n\r\nconst base64EncodedConditionalImport = base64EncodedImport;\r\n\r\nvar applyConditions$1 = function applyConditions(bundle, atRule) {\r\n  bundle.forEach(stmt => {\r\n    if (\r\n      stmt.type === \"charset\" ||\r\n      stmt.type === \"warning\" ||\r\n      !stmt.conditions?.length\r\n    ) {\r\n      return\r\n    }\r\n\r\n    if (stmt.type === \"import\") {\r\n      stmt.node.params = base64EncodedConditionalImport(\r\n        stmt.fullUri,\r\n        stmt.conditions,\r\n      );\r\n      return\r\n    }\r\n\r\n    const { nodes } = stmt;\r\n    const { parent } = nodes[0];\r\n\r\n    const atRules = [];\r\n\r\n    // Convert conditions to at-rules\r\n    for (const condition of stmt.conditions) {\r\n      if (typeof condition.media !== \"undefined\") {\r\n        const mediaNode = atRule({\r\n          name: \"media\",\r\n          params: condition.media,\r\n          source: parent.source,\r\n        });\r\n\r\n        atRules.push(mediaNode);\r\n      }\r\n\r\n      if (typeof condition.supports !== \"undefined\") {\r\n        const supportsNode = atRule({\r\n          name: \"supports\",\r\n          params: `(${condition.supports})`,\r\n          source: parent.source,\r\n        });\r\n\r\n        atRules.push(supportsNode);\r\n      }\r\n\r\n      if (typeof condition.layer !== \"undefined\") {\r\n        const layerNode = atRule({\r\n          name: \"layer\",\r\n          params: condition.layer,\r\n          source: parent.source,\r\n        });\r\n\r\n        atRules.push(layerNode);\r\n      }\r\n    }\r\n\r\n    // Add nodes to AST\r\n    const outerAtRule = atRules.shift();\r\n    const innerAtRule = atRules.reduce((previous, next) => {\r\n      previous.append(next);\r\n      return next\r\n    }, outerAtRule);\r\n\r\n    parent.insertBefore(nodes[0], outerAtRule);\r\n\r\n    // remove nodes\r\n    nodes.forEach(node => {\r\n      node.parent = undefined;\r\n    });\r\n\r\n    // better output\r\n    nodes[0].raws.before = nodes[0].raws.before || \"\\n\";\r\n\r\n    // wrap new rules with media query and/or layer at rule\r\n    innerAtRule.append(nodes);\r\n\r\n    stmt.type = \"nodes\";\r\n    stmt.nodes = [outerAtRule];\r\n    delete stmt.node;\r\n  });\r\n};\r\n\r\nvar applyRaws$1 = function applyRaws(bundle) {\r\n  bundle.forEach((stmt, index) => {\r\n    if (index === 0) return\r\n\r\n    if (stmt.parent) {\r\n      const { before } = stmt.parent.node.raws;\r\n      if (stmt.type === \"nodes\") stmt.nodes[0].raws.before = before;\r\n      else stmt.node.raws.before = before;\r\n    } else if (stmt.type === \"nodes\") {\r\n      stmt.nodes[0].raws.before = stmt.nodes[0].raws.before || \"\\n\";\r\n    }\r\n  });\r\n};\r\n\r\nvar applyStyles$1 = function applyStyles(bundle, styles) {\r\n  styles.nodes = [];\r\n\r\n  // Strip additional statements.\r\n  bundle.forEach(stmt => {\r\n    if ([\"charset\", \"import\"].includes(stmt.type)) {\r\n      stmt.node.parent = undefined;\r\n      styles.append(stmt.node);\r\n    } else if (stmt.type === \"nodes\") {\r\n      stmt.nodes.forEach(node => {\r\n        node.parent = undefined;\r\n        styles.append(node);\r\n      });\r\n    }\r\n  });\r\n};\r\n\r\nvar readCache$1 = {exports: {}};\r\n\r\nvar pify$2 = {exports: {}};\r\n\r\nvar processFn = function (fn, P, opts) {\r\n\treturn function () {\r\n\t\tvar that = this;\r\n\t\tvar args = new Array(arguments.length);\r\n\r\n\t\tfor (var i = 0; i < arguments.length; i++) {\r\n\t\t\targs[i] = arguments[i];\r\n\t\t}\r\n\r\n\t\treturn new P(function (resolve, reject) {\r\n\t\t\targs.push(function (err, result) {\r\n\t\t\t\tif (err) {\r\n\t\t\t\t\treject(err);\r\n\t\t\t\t} else if (opts.multiArgs) {\r\n\t\t\t\t\tvar results = new Array(arguments.length - 1);\r\n\r\n\t\t\t\t\tfor (var i = 1; i < arguments.length; i++) {\r\n\t\t\t\t\t\tresults[i - 1] = arguments[i];\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tresolve(results);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tresolve(result);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\tfn.apply(that, args);\r\n\t\t});\r\n\t};\r\n};\r\n\r\nvar pify$1 = pify$2.exports = function (obj, P, opts) {\r\n\tif (typeof P !== 'function') {\r\n\t\topts = P;\r\n\t\tP = Promise;\r\n\t}\r\n\r\n\topts = opts || {};\r\n\topts.exclude = opts.exclude || [/.+Sync$/];\r\n\r\n\tvar filter = function (key) {\r\n\t\tvar match = function (pattern) {\r\n\t\t\treturn typeof pattern === 'string' ? key === pattern : pattern.test(key);\r\n\t\t};\r\n\r\n\t\treturn opts.include ? opts.include.some(match) : !opts.exclude.some(match);\r\n\t};\r\n\r\n\tvar ret = typeof obj === 'function' ? function () {\r\n\t\tif (opts.excludeMain) {\r\n\t\t\treturn obj.apply(this, arguments);\r\n\t\t}\r\n\r\n\t\treturn processFn(obj, P, opts).apply(this, arguments);\r\n\t} : {};\r\n\r\n\treturn Object.keys(obj).reduce(function (ret, key) {\r\n\t\tvar x = obj[key];\r\n\r\n\t\tret[key] = typeof x === 'function' && filter(key) ? processFn(x, P, opts) : x;\r\n\r\n\t\treturn ret;\r\n\t}, ret);\r\n};\r\n\r\npify$1.all = pify$1;\r\n\r\nvar pifyExports = pify$2.exports;\r\n\r\nvar fs = require$$0__default;\r\nvar path$3 = require$$0;\r\nvar pify = pifyExports;\r\n\r\nvar stat = pify(fs.stat);\r\nvar readFile = pify(fs.readFile);\r\nvar resolve = path$3.resolve;\r\n\r\nvar cache = Object.create(null);\r\n\r\nfunction convert(content, encoding) {\r\n\tif (Buffer.isEncoding(encoding)) {\r\n\t\treturn content.toString(encoding);\r\n\t}\r\n\treturn content;\r\n}\r\n\r\nreadCache$1.exports = function (path, encoding) {\r\n\tpath = resolve(path);\r\n\r\n\treturn stat(path).then(function (stats) {\r\n\t\tvar item = cache[path];\r\n\r\n\t\tif (item && item.mtime.getTime() === stats.mtime.getTime()) {\r\n\t\t\treturn convert(item.content, encoding);\r\n\t\t}\r\n\r\n\t\treturn readFile(path).then(function (data) {\r\n\t\t\tcache[path] = {\r\n\t\t\t\tmtime: stats.mtime,\r\n\t\t\t\tcontent: data\r\n\t\t\t};\r\n\r\n\t\t\treturn convert(data, encoding);\r\n\t\t});\r\n\t}).catch(function (err) {\r\n\t\tcache[path] = null;\r\n\t\treturn Promise.reject(err);\r\n\t});\r\n};\r\n\r\nreadCache$1.exports.sync = function (path, encoding) {\r\n\tpath = resolve(path);\r\n\r\n\ttry {\r\n\t\tvar stats = fs.statSync(path);\r\n\t\tvar item = cache[path];\r\n\r\n\t\tif (item && item.mtime.getTime() === stats.mtime.getTime()) {\r\n\t\t\treturn convert(item.content, encoding);\r\n\t\t}\r\n\r\n\t\tvar data = fs.readFileSync(path);\r\n\r\n\t\tcache[path] = {\r\n\t\t\tmtime: stats.mtime,\r\n\t\t\tcontent: data\r\n\t\t};\r\n\r\n\t\treturn convert(data, encoding);\r\n\t} catch (err) {\r\n\t\tcache[path] = null;\r\n\t\tthrow err;\r\n\t}\r\n\r\n};\r\n\r\nreadCache$1.exports.get = function (path, encoding) {\r\n\tpath = resolve(path);\r\n\tif (cache[path]) {\r\n\t\treturn convert(cache[path].content, encoding);\r\n\t}\r\n\treturn null;\r\n};\r\n\r\nreadCache$1.exports.clear = function () {\r\n\tcache = Object.create(null);\r\n};\r\n\r\nvar readCacheExports = readCache$1.exports;\r\n\r\nconst anyDataURLRegexp = /^data:text\\/css(?:;(base64|plain))?,/i;\r\nconst base64DataURLRegexp = /^data:text\\/css;base64,/i;\r\nconst plainDataURLRegexp = /^data:text\\/css;plain,/i;\r\n\r\nfunction isValid(url) {\r\n  return anyDataURLRegexp.test(url)\r\n}\r\n\r\nfunction contents(url) {\r\n  if (base64DataURLRegexp.test(url)) {\r\n    // \"data:text/css;base64,\".length === 21\r\n    return Buffer.from(url.slice(21), \"base64\").toString()\r\n  }\r\n\r\n  if (plainDataURLRegexp.test(url)) {\r\n    // \"data:text/css;plain,\".length === 20\r\n    return decodeURIComponent(url.slice(20))\r\n  }\r\n\r\n  // \"data:text/css,\".length === 14\r\n  return decodeURIComponent(url.slice(14))\r\n}\r\n\r\nvar dataUrl = {\r\n  isValid,\r\n  contents,\r\n};\r\n\r\nconst readCache = readCacheExports;\r\nconst dataURL$1 = dataUrl;\r\n\r\nvar loadContent$1 = function loadContent(filename) {\r\n  if (dataURL$1.isValid(filename)) {\r\n    return dataURL$1.contents(filename)\r\n  }\r\n\r\n  return readCache(filename, \"utf-8\")\r\n};\r\n\r\n// external tooling\r\nconst valueParser = lib;\r\n\r\n// extended tooling\r\nconst { stringify } = valueParser;\r\n\r\nvar parseStatements$1 = function parseStatements(result, styles, conditions, from) {\r\n  const statements = [];\r\n  let nodes = [];\r\n\r\n  styles.each(node => {\r\n    let stmt;\r\n    if (node.type === \"atrule\") {\r\n      if (node.name === \"import\")\r\n        stmt = parseImport(result, node, conditions, from);\r\n      else if (node.name === \"charset\")\r\n        stmt = parseCharset(result, node, conditions, from);\r\n    }\r\n\r\n    if (stmt) {\r\n      if (nodes.length) {\r\n        statements.push({\r\n          type: \"nodes\",\r\n          nodes,\r\n          conditions: [...conditions],\r\n          from,\r\n        });\r\n        nodes = [];\r\n      }\r\n      statements.push(stmt);\r\n    } else nodes.push(node);\r\n  });\r\n\r\n  if (nodes.length) {\r\n    statements.push({\r\n      type: \"nodes\",\r\n      nodes,\r\n      conditions: [...conditions],\r\n      from,\r\n    });\r\n  }\r\n\r\n  return statements\r\n};\r\n\r\nfunction parseCharset(result, atRule, conditions, from) {\r\n  if (atRule.prev()) {\r\n    return result.warn(\"@charset must precede all other statements\", {\r\n      node: atRule,\r\n    })\r\n  }\r\n  return {\r\n    type: \"charset\",\r\n    node: atRule,\r\n    conditions: [...conditions],\r\n    from,\r\n  }\r\n}\r\n\r\nfunction parseImport(result, atRule, conditions, from) {\r\n  let prev = atRule.prev();\r\n\r\n  // `@import` statements may follow other `@import` statements.\r\n  if (prev) {\r\n    do {\r\n      if (\r\n        prev.type === \"comment\" ||\r\n        (prev.type === \"atrule\" && prev.name === \"import\")\r\n      ) {\r\n        prev = prev.prev();\r\n        continue\r\n      }\r\n\r\n      break\r\n    } while (prev)\r\n  }\r\n\r\n  // All `@import` statements may be preceded by `@charset` or `@layer` statements.\r\n  // But the `@import` statements must be consecutive.\r\n  if (prev) {\r\n    do {\r\n      if (\r\n        prev.type === \"comment\" ||\r\n        (prev.type === \"atrule\" &&\r\n          (prev.name === \"charset\" || (prev.name === \"layer\" && !prev.nodes)))\r\n      ) {\r\n        prev = prev.prev();\r\n        continue\r\n      }\r\n\r\n      return result.warn(\r\n        \"@import must precede all other statements (besides @charset or empty @layer)\",\r\n        { node: atRule },\r\n      )\r\n    } while (prev)\r\n  }\r\n\r\n  if (atRule.nodes) {\r\n    return result.warn(\r\n      \"It looks like you didn't end your @import statement correctly. \" +\r\n        \"Child nodes are attached to it.\",\r\n      { node: atRule },\r\n    )\r\n  }\r\n\r\n  const params = valueParser(atRule.params).nodes;\r\n  const stmt = {\r\n    type: \"import\",\r\n    uri: \"\",\r\n    fullUri: \"\",\r\n    node: atRule,\r\n    conditions: [...conditions],\r\n    from,\r\n  };\r\n\r\n  let layer;\r\n  let media;\r\n  let supports;\r\n\r\n  for (let i = 0; i < params.length; i++) {\r\n    const node = params[i];\r\n\r\n    if (node.type === \"space\" || node.type === \"comment\") continue\r\n\r\n    if (node.type === \"string\") {\r\n      if (stmt.uri) {\r\n        return result.warn(`Multiple url's in '${atRule.toString()}'`, {\r\n          node: atRule,\r\n        })\r\n      }\r\n\r\n      if (!node.value) {\r\n        return result.warn(`Unable to find uri in '${atRule.toString()}'`, {\r\n          node: atRule,\r\n        })\r\n      }\r\n\r\n      stmt.uri = node.value;\r\n      stmt.fullUri = stringify(node);\r\n      continue\r\n    }\r\n\r\n    if (node.type === \"function\" && /^url$/i.test(node.value)) {\r\n      if (stmt.uri) {\r\n        return result.warn(`Multiple url's in '${atRule.toString()}'`, {\r\n          node: atRule,\r\n        })\r\n      }\r\n\r\n      if (!node.nodes?.[0]?.value) {\r\n        return result.warn(`Unable to find uri in '${atRule.toString()}'`, {\r\n          node: atRule,\r\n        })\r\n      }\r\n\r\n      stmt.uri = node.nodes[0].value;\r\n      stmt.fullUri = stringify(node);\r\n      continue\r\n    }\r\n\r\n    if (!stmt.uri) {\r\n      return result.warn(`Unable to find uri in '${atRule.toString()}'`, {\r\n        node: atRule,\r\n      })\r\n    }\r\n\r\n    if (\r\n      (node.type === \"word\" || node.type === \"function\") &&\r\n      /^layer$/i.test(node.value)\r\n    ) {\r\n      if (typeof layer !== \"undefined\") {\r\n        return result.warn(`Multiple layers in '${atRule.toString()}'`, {\r\n          node: atRule,\r\n        })\r\n      }\r\n\r\n      if (typeof supports !== \"undefined\") {\r\n        return result.warn(\r\n          `layers must be defined before support conditions in '${atRule.toString()}'`,\r\n          {\r\n            node: atRule,\r\n          },\r\n        )\r\n      }\r\n\r\n      if (node.nodes) {\r\n        layer = stringify(node.nodes);\r\n      } else {\r\n        layer = \"\";\r\n      }\r\n\r\n      continue\r\n    }\r\n\r\n    if (node.type === \"function\" && /^supports$/i.test(node.value)) {\r\n      if (typeof supports !== \"undefined\") {\r\n        return result.warn(\r\n          `Multiple support conditions in '${atRule.toString()}'`,\r\n          {\r\n            node: atRule,\r\n          },\r\n        )\r\n      }\r\n\r\n      supports = stringify(node.nodes);\r\n\r\n      continue\r\n    }\r\n\r\n    media = stringify(params.slice(i));\r\n    break\r\n  }\r\n\r\n  if (!stmt.uri) {\r\n    return result.warn(`Unable to find uri in '${atRule.toString()}'`, {\r\n      node: atRule,\r\n    })\r\n  }\r\n\r\n  if (\r\n    typeof media !== \"undefined\" ||\r\n    typeof layer !== \"undefined\" ||\r\n    typeof supports !== \"undefined\"\r\n  ) {\r\n    stmt.conditions.push({\r\n      layer,\r\n      media,\r\n      supports,\r\n    });\r\n  }\r\n\r\n  return stmt\r\n}\r\n\r\n// builtin tooling\r\nconst path$2 = require$$0;\r\n\r\n// placeholder tooling\r\nlet sugarss;\r\n\r\nvar processContent$1 = function processContent(\r\n  result,\r\n  content,\r\n  filename,\r\n  options,\r\n  postcss,\r\n) {\r\n  const { plugins } = options;\r\n  const ext = path$2.extname(filename);\r\n\r\n  const parserList = [];\r\n\r\n  // SugarSS support:\r\n  if (ext === \".sss\") {\r\n    if (!sugarss) {\r\n      /* c8 ignore next 3 */\r\n      try {\r\n        sugarss = __require('sugarss');\r\n      } catch {} // Ignore\r\n    }\r\n    if (sugarss)\r\n      return runPostcss(postcss, content, filename, plugins, [sugarss])\r\n  }\r\n\r\n  // Syntax support:\r\n  if (result.opts.syntax?.parse) {\r\n    parserList.push(result.opts.syntax.parse);\r\n  }\r\n\r\n  // Parser support:\r\n  if (result.opts.parser) parserList.push(result.opts.parser);\r\n  // Try the default as a last resort:\r\n  parserList.push(null);\r\n\r\n  return runPostcss(postcss, content, filename, plugins, parserList)\r\n};\r\n\r\nfunction runPostcss(postcss, content, filename, plugins, parsers, index) {\r\n  if (!index) index = 0;\r\n  return postcss(plugins)\r\n    .process(content, {\r\n      from: filename,\r\n      parser: parsers[index],\r\n    })\r\n    .catch(err => {\r\n      // If there's an error, try the next parser\r\n      index++;\r\n      // If there are no parsers left, throw it\r\n      if (index === parsers.length) throw err\r\n      return runPostcss(postcss, content, filename, plugins, parsers, index)\r\n    })\r\n}\r\n\r\nconst path$1 = require$$0;\r\n\r\nconst dataURL = dataUrl;\r\nconst parseStatements = parseStatements$1;\r\nconst processContent = processContent$1;\r\nconst resolveId$1 = (id) => id;\r\nconst formatImportPrelude = formatImportPrelude$2;\r\n\r\nasync function parseStyles$1(\r\n  result,\r\n  styles,\r\n  options,\r\n  state,\r\n  conditions,\r\n  from,\r\n  postcss,\r\n) {\r\n  const statements = parseStatements(result, styles, conditions, from);\r\n\r\n  for (const stmt of statements) {\r\n    if (stmt.type !== \"import\" || !isProcessableURL(stmt.uri)) {\r\n      continue\r\n    }\r\n\r\n    if (options.filter && !options.filter(stmt.uri)) {\r\n      // rejected by filter\r\n      continue\r\n    }\r\n\r\n    await resolveImportId(result, stmt, options, state, postcss);\r\n  }\r\n\r\n  let charset;\r\n  const imports = [];\r\n  const bundle = [];\r\n\r\n  function handleCharset(stmt) {\r\n    if (!charset) charset = stmt;\r\n    // charsets aren't case-sensitive, so convert to lower case to compare\r\n    else if (\r\n      stmt.node.params.toLowerCase() !== charset.node.params.toLowerCase()\r\n    ) {\r\n      throw stmt.node.error(\r\n        `Incompatible @charset statements:\r\n  ${stmt.node.params} specified in ${stmt.node.source.input.file}\r\n  ${charset.node.params} specified in ${charset.node.source.input.file}`,\r\n      )\r\n    }\r\n  }\r\n\r\n  // squash statements and their children\r\n  statements.forEach(stmt => {\r\n    if (stmt.type === \"charset\") handleCharset(stmt);\r\n    else if (stmt.type === \"import\") {\r\n      if (stmt.children) {\r\n        stmt.children.forEach((child, index) => {\r\n          if (child.type === \"import\") imports.push(child);\r\n          else if (child.type === \"charset\") handleCharset(child);\r\n          else bundle.push(child);\r\n          // For better output\r\n          if (index === 0) child.parent = stmt;\r\n        });\r\n      } else imports.push(stmt);\r\n    } else if (stmt.type === \"nodes\") {\r\n      bundle.push(stmt);\r\n    }\r\n  });\r\n\r\n  return charset ? [charset, ...imports.concat(bundle)] : imports.concat(bundle)\r\n}\r\n\r\nasync function resolveImportId(result, stmt, options, state, postcss) {\r\n  if (dataURL.isValid(stmt.uri)) {\r\n    // eslint-disable-next-line require-atomic-updates\r\n    stmt.children = await loadImportContent(\r\n      result,\r\n      stmt,\r\n      stmt.uri,\r\n      options,\r\n      state,\r\n      postcss,\r\n    );\r\n\r\n    return\r\n  } else if (dataURL.isValid(stmt.from.slice(-1))) {\r\n    // Data urls can't be used as a base url to resolve imports.\r\n    throw stmt.node.error(\r\n      `Unable to import '${stmt.uri}' from a stylesheet that is embedded in a data url`,\r\n    )\r\n  }\r\n\r\n  const atRule = stmt.node;\r\n  let sourceFile;\r\n  if (atRule.source?.input?.file) {\r\n    sourceFile = atRule.source.input.file;\r\n  }\r\n  const base = sourceFile\r\n    ? path$1.dirname(atRule.source.input.file)\r\n    : options.root;\r\n\r\n  const paths = [await options.resolve(stmt.uri, base, options, atRule)].flat();\r\n\r\n  // Ensure that each path is absolute:\r\n  const resolved = await Promise.all(\r\n    paths.map(file => {\r\n      return !path$1.isAbsolute(file)\r\n        ? resolveId$1(file)\r\n        : file\r\n    }),\r\n  );\r\n\r\n  // Add dependency messages:\r\n  resolved.forEach(file => {\r\n    result.messages.push({\r\n      type: \"dependency\",\r\n      plugin: \"postcss-import\",\r\n      file,\r\n      parent: sourceFile,\r\n    });\r\n  });\r\n\r\n  const importedContent = await Promise.all(\r\n    resolved.map(file => {\r\n      return loadImportContent(result, stmt, file, options, state, postcss)\r\n    }),\r\n  );\r\n\r\n  // Merge loaded statements\r\n  // eslint-disable-next-line require-atomic-updates\r\n  stmt.children = importedContent.flat().filter(x => !!x);\r\n}\r\n\r\nasync function loadImportContent(\r\n  result,\r\n  stmt,\r\n  filename,\r\n  options,\r\n  state,\r\n  postcss,\r\n) {\r\n  const atRule = stmt.node;\r\n  const { conditions, from } = stmt;\r\n  const stmtDuplicateCheckKey = conditions\r\n    .map(condition =>\r\n      formatImportPrelude(condition.layer, condition.media, condition.supports),\r\n    )\r\n    .join(\":\");\r\n\r\n  if (options.skipDuplicates) {\r\n    // skip files already imported at the same scope\r\n    if (state.importedFiles[filename]?.[stmtDuplicateCheckKey]) {\r\n      return\r\n    }\r\n\r\n    // save imported files to skip them next time\r\n    if (!state.importedFiles[filename]) {\r\n      state.importedFiles[filename] = {};\r\n    }\r\n    state.importedFiles[filename][stmtDuplicateCheckKey] = true;\r\n  }\r\n\r\n  if (from.includes(filename)) {\r\n    return\r\n  }\r\n\r\n  const content = await options.load(filename, options);\r\n\r\n  if (content.trim() === \"\" && options.warnOnEmpty) {\r\n    result.warn(`${filename} is empty`, { node: atRule });\r\n    return\r\n  }\r\n\r\n  // skip previous imported files not containing @import rules\r\n  if (\r\n    options.skipDuplicates &&\r\n    state.hashFiles[content]?.[stmtDuplicateCheckKey]\r\n  ) {\r\n    return\r\n  }\r\n\r\n  const importedResult = await processContent(\r\n    result,\r\n    content,\r\n    filename,\r\n    options,\r\n    postcss,\r\n  );\r\n\r\n  const styles = importedResult.root;\r\n  result.messages = result.messages.concat(importedResult.messages);\r\n\r\n  if (options.skipDuplicates) {\r\n    const hasImport = styles.some(child => {\r\n      return child.type === \"atrule\" && child.name === \"import\"\r\n    });\r\n    if (!hasImport) {\r\n      // save hash files to skip them next time\r\n      if (!state.hashFiles[content]) {\r\n        state.hashFiles[content] = {};\r\n      }\r\n\r\n      state.hashFiles[content][stmtDuplicateCheckKey] = true;\r\n    }\r\n  }\r\n\r\n  // recursion: import @import from imported file\r\n  return parseStyles$1(\r\n    result,\r\n    styles,\r\n    options,\r\n    state,\r\n    conditions,\r\n    [...from, filename],\r\n    postcss,\r\n  )\r\n}\r\n\r\nfunction isProcessableURL(uri) {\r\n  // skip protocol base uri (protocol://url) or protocol-relative\r\n  if (/^(?:[a-z]+:)?\\/\\//i.test(uri)) {\r\n    return false\r\n  }\r\n\r\n  // PATCH: comment out this part to support resolving imports field\r\n  // // check for fragment or query\r\n  // try {\r\n  //   // needs a base to parse properly\r\n  //   const url = new URL(uri, \"https://example.com\")\r\n\r\n  //   if (url.hash) {\r\n  //     return false\r\n  //   }\r\n\r\n  //   if (url.search) {\r\n  //     return false\r\n  //   }\r\n  // } catch {} // Ignore\r\n\r\n  return true\r\n}\r\n\r\nvar parseStyles_1 = parseStyles$1;\r\n\r\n// builtin tooling\r\nconst path = require$$0;\r\n\r\n// internal tooling\r\nconst applyConditions = applyConditions$1;\r\nconst applyRaws = applyRaws$1;\r\nconst applyStyles = applyStyles$1;\r\nconst loadContent = loadContent$1;\r\nconst parseStyles = parseStyles_1;\r\nconst resolveId = (id) => id;\r\n\r\nfunction AtImport(options) {\r\n  options = {\r\n    root: process.cwd(),\r\n    path: [],\r\n    skipDuplicates: true,\r\n    resolve: resolveId,\r\n    load: loadContent,\r\n    plugins: [],\r\n    addModulesDirectories: [],\r\n    warnOnEmpty: true,\r\n    ...options,\r\n  };\r\n\r\n  options.root = path.resolve(options.root);\r\n\r\n  // convert string to an array of a single element\r\n  if (typeof options.path === \"string\") options.path = [options.path];\r\n\r\n  if (!Array.isArray(options.path)) options.path = [];\r\n\r\n  options.path = options.path.map(p => path.resolve(options.root, p));\r\n\r\n  return {\r\n    postcssPlugin: \"postcss-import\",\r\n    async Once(styles, { result, atRule, postcss }) {\r\n      const state = {\r\n        importedFiles: {},\r\n        hashFiles: {},\r\n      };\r\n\r\n      if (styles.source?.input?.file) {\r\n        state.importedFiles[styles.source.input.file] = {};\r\n      }\r\n\r\n      if (options.plugins && !Array.isArray(options.plugins)) {\r\n        throw new Error(\"plugins option must be an array\")\r\n      }\r\n\r\n      const bundle = await parseStyles(\r\n        result,\r\n        styles,\r\n        options,\r\n        state,\r\n        [],\r\n        [],\r\n        postcss,\r\n      );\r\n\r\n      applyRaws(bundle);\r\n      applyConditions(bundle, atRule);\r\n      applyStyles(bundle, styles);\r\n    },\r\n  }\r\n}\r\n\r\nAtImport.postcss = true;\r\n\r\nvar postcssImport = AtImport;\r\n\r\nvar index = /*@__PURE__*/getDefaultExportFromCjs(postcssImport);\r\n\r\nvar index$1 = /*#__PURE__*/_mergeNamespaces({\r\n  __proto__: null,\r\n  default: index\r\n}, [postcssImport]);\r\n\r\nexport { index$1 as i };\r\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,kBAAuB;AACvB,gBAAgC;AAGhC,sBAAqD;AACrD,uBAAyC;AACzC,yBAAqD;AAErD,IAAM,iBAAa,gBAAAA,eAAoB,YAAY,GAAG;AACtD,IAAM,gBAAY,iBAAAC,SAAc,UAAU;AAC1C,IAAMC,eAAU,mBAAAC,eAAoB,YAAY,GAAG;AACnD,IAAM,YAAYD;AAClB,SAAS,iBAAiB,GAAG,GAAG;AAC9B,WAAS,IAAI,GAAG,IAAI,EAAE,QAAQ,KAAK;AACjC,QAAI,IAAI,EAAE,CAAC;AACX,QAAI,OAAO,MAAM,YAAY,CAAC,MAAM,QAAQ,CAAC,GAAG;AAAE,eAAS,KAAK,GAAG;AACjE,YAAI,MAAM,aAAa,EAAE,KAAK,IAAI;AAChC,YAAE,CAAC,IAAI,EAAE,CAAC;AAAA,QACZ;AAAA,MACF;AAAA,IAAE;AAAA,EACJ;AACA,SAAO;AACT;AAEA,IAAI,wBAAwB,SAAS,oBAAoB,OAAO,OAAO,UAAU;AAC/E,QAAM,QAAQ,CAAC;AAEf,MAAI,OAAO,UAAU,aAAa;AAChC,QAAI,cAAc;AAClB,QAAI,OAAO;AACT,oBAAc,SAAS,KAAK;AAAA,IAC9B;AAEA,UAAM,KAAK,WAAW;AAAA,EACxB;AAEA,MAAI,OAAO,aAAa,aAAa;AACnC,UAAM,KAAK,YAAY,QAAQ,GAAG;AAAA,EACpC;AAEA,MAAI,OAAO,UAAU,aAAa;AAChC,UAAM,KAAK,KAAK;AAAA,EAClB;AAEA,SAAO,MAAM,KAAK,GAAG;AACvB;AAEA,IAAM,wBAAwB;AAO9B,IAAI,sBAAsB,SAAS,+BAA+B,SAAS,YAAY;AACrF,aAAW,QAAQ;AACnB,QAAM,QAAQ,WAAW,IAAI;AAC7B,MAAI,SAAS,GAAG,OAAO,IAAI;AAAA,IACzB,MAAM;AAAA,IACN,MAAM;AAAA,IACN,MAAM;AAAA,EACR,CAAC;AAED,aAAW,aAAa,YAAY;AAClC,aAAS,yBAAyB,OAAO,KAAK,WAAW,MAAM,EAAE,EAAE;AAAA,MACjE;AAAA,IACF,CAAC,KAAK;AAAA,MACJ,UAAU;AAAA,MACV,UAAU;AAAA,MACV,UAAU;AAAA,IACZ,CAAC;AAAA,EACH;AAEA,SAAO;AACT;AAEA,IAAME,kCAAiC;AAEvC,IAAI,oBAAoB,SAAS,gBAAgB,QAAQ,QAAQ;AAC/D,SAAO,QAAQ,UAAQ;AAhFzB;AAiFI,QACE,KAAK,SAAS,aACd,KAAK,SAAS,aACd,GAAC,UAAK,eAAL,mBAAiB,SAClB;AACA;AAAA,IACF;AAEA,QAAI,KAAK,SAAS,UAAU;AAC1B,WAAK,KAAK,SAASA;AAAA,QACjB,KAAK;AAAA,QACL,KAAK;AAAA,MACP;AACA;AAAA,IACF;AAEA,UAAM,EAAE,MAAM,IAAI;AAClB,UAAM,EAAE,OAAO,IAAI,MAAM,CAAC;AAE1B,UAAM,UAAU,CAAC;AAGjB,eAAW,aAAa,KAAK,YAAY;AACvC,UAAI,OAAO,UAAU,UAAU,aAAa;AAC1C,cAAM,YAAY,OAAO;AAAA,UACvB,MAAM;AAAA,UACN,QAAQ,UAAU;AAAA,UAClB,QAAQ,OAAO;AAAA,QACjB,CAAC;AAED,gBAAQ,KAAK,SAAS;AAAA,MACxB;AAEA,UAAI,OAAO,UAAU,aAAa,aAAa;AAC7C,cAAM,eAAe,OAAO;AAAA,UAC1B,MAAM;AAAA,UACN,QAAQ,IAAI,UAAU,QAAQ;AAAA,UAC9B,QAAQ,OAAO;AAAA,QACjB,CAAC;AAED,gBAAQ,KAAK,YAAY;AAAA,MAC3B;AAEA,UAAI,OAAO,UAAU,UAAU,aAAa;AAC1C,cAAM,YAAY,OAAO;AAAA,UACvB,MAAM;AAAA,UACN,QAAQ,UAAU;AAAA,UAClB,QAAQ,OAAO;AAAA,QACjB,CAAC;AAED,gBAAQ,KAAK,SAAS;AAAA,MACxB;AAAA,IACF;AAGA,UAAM,cAAc,QAAQ,MAAM;AAClC,UAAM,cAAc,QAAQ,OAAO,CAAC,UAAU,SAAS;AACrD,eAAS,OAAO,IAAI;AACpB,aAAO;AAAA,IACT,GAAG,WAAW;AAEd,WAAO,aAAa,MAAM,CAAC,GAAG,WAAW;AAGzC,UAAM,QAAQ,UAAQ;AACpB,WAAK,SAAS;AAAA,IAChB,CAAC;AAGD,UAAM,CAAC,EAAE,KAAK,SAAS,MAAM,CAAC,EAAE,KAAK,UAAU;AAG/C,gBAAY,OAAO,KAAK;AAExB,SAAK,OAAO;AACZ,SAAK,QAAQ,CAAC,WAAW;AACzB,WAAO,KAAK;AAAA,EACd,CAAC;AACH;AAEA,IAAI,cAAc,SAAS,UAAU,QAAQ;AAC3C,SAAO,QAAQ,CAAC,MAAMC,WAAU;AAC9B,QAAIA,WAAU;AAAG;AAEjB,QAAI,KAAK,QAAQ;AACf,YAAM,EAAE,OAAO,IAAI,KAAK,OAAO,KAAK;AACpC,UAAI,KAAK,SAAS;AAAS,aAAK,MAAM,CAAC,EAAE,KAAK,SAAS;AAAA;AAClD,aAAK,KAAK,KAAK,SAAS;AAAA,IAC/B,WAAW,KAAK,SAAS,SAAS;AAChC,WAAK,MAAM,CAAC,EAAE,KAAK,SAAS,KAAK,MAAM,CAAC,EAAE,KAAK,UAAU;AAAA,IAC3D;AAAA,EACF,CAAC;AACH;AAEA,IAAI,gBAAgB,SAAS,YAAY,QAAQ,QAAQ;AACvD,SAAO,QAAQ,CAAC;AAGhB,SAAO,QAAQ,UAAQ;AACrB,QAAI,CAAC,WAAW,QAAQ,EAAE,SAAS,KAAK,IAAI,GAAG;AAC7C,WAAK,KAAK,SAAS;AACnB,aAAO,OAAO,KAAK,IAAI;AAAA,IACzB,WAAW,KAAK,SAAS,SAAS;AAChC,WAAK,MAAM,QAAQ,UAAQ;AACzB,aAAK,SAAS;AACd,eAAO,OAAO,IAAI;AAAA,MACpB,CAAC;AAAA,IACH;AAAA,EACF,CAAC;AACH;AAEA,IAAI,cAAc,EAAC,SAAS,CAAC,EAAC;AAE9B,IAAI,SAAS,EAAC,SAAS,CAAC,EAAC;AAEzB,IAAI,YAAY,SAAU,IAAI,GAAG,MAAM;AACtC,SAAO,WAAY;AAClB,QAAI,OAAO;AACX,QAAI,OAAO,IAAI,MAAM,UAAU,MAAM;AAErC,aAAS,IAAI,GAAG,IAAI,UAAU,QAAQ,KAAK;AAC1C,WAAK,CAAC,IAAI,UAAU,CAAC;AAAA,IACtB;AAEA,WAAO,IAAI,EAAE,SAAUC,UAAS,QAAQ;AACvC,WAAK,KAAK,SAAU,KAAK,QAAQ;AAChC,YAAI,KAAK;AACR,iBAAO,GAAG;AAAA,QACX,WAAW,KAAK,WAAW;AAC1B,cAAI,UAAU,IAAI,MAAM,UAAU,SAAS,CAAC;AAE5C,mBAASC,KAAI,GAAGA,KAAI,UAAU,QAAQA,MAAK;AAC1C,oBAAQA,KAAI,CAAC,IAAI,UAAUA,EAAC;AAAA,UAC7B;AAEA,UAAAD,SAAQ,OAAO;AAAA,QAChB,OAAO;AACN,UAAAA,SAAQ,MAAM;AAAA,QACf;AAAA,MACD,CAAC;AAED,SAAG,MAAM,MAAM,IAAI;AAAA,IACpB,CAAC;AAAA,EACF;AACD;AAEA,IAAI,SAAS,OAAO,UAAU,SAAU,KAAK,GAAG,MAAM;AACrD,MAAI,OAAO,MAAM,YAAY;AAC5B,WAAO;AACP,QAAI;AAAA,EACL;AAEA,SAAO,QAAQ,CAAC;AAChB,OAAK,UAAU,KAAK,WAAW,CAAC,SAAS;AAEzC,MAAI,SAAS,SAAU,KAAK;AAC3B,QAAI,QAAQ,SAAU,SAAS;AAC9B,aAAO,OAAO,YAAY,WAAW,QAAQ,UAAU,QAAQ,KAAK,GAAG;AAAA,IACxE;AAEA,WAAO,KAAK,UAAU,KAAK,QAAQ,KAAK,KAAK,IAAI,CAAC,KAAK,QAAQ,KAAK,KAAK;AAAA,EAC1E;AAEA,MAAI,MAAM,OAAO,QAAQ,aAAa,WAAY;AACjD,QAAI,KAAK,aAAa;AACrB,aAAO,IAAI,MAAM,MAAM,SAAS;AAAA,IACjC;AAEA,WAAO,UAAU,KAAK,GAAG,IAAI,EAAE,MAAM,MAAM,SAAS;AAAA,EACrD,IAAI,CAAC;AAEL,SAAO,OAAO,KAAK,GAAG,EAAE,OAAO,SAAUE,MAAK,KAAK;AAClD,QAAI,IAAI,IAAI,GAAG;AAEf,IAAAA,KAAI,GAAG,IAAI,OAAO,MAAM,cAAc,OAAO,GAAG,IAAI,UAAU,GAAG,GAAG,IAAI,IAAI;AAE5E,WAAOA;AAAA,EACR,GAAG,GAAG;AACP;AAEA,OAAO,MAAM;AAEb,IAAI,cAAc,OAAO;AAEzB,IAAI,KAAK,UAAAC;AACT,IAAI,SAAS,YAAAC;AACb,IAAI,OAAO;AAEX,IAAI,OAAO,KAAK,GAAG,IAAI;AACvB,IAAI,WAAW,KAAK,GAAG,QAAQ;AAC/B,IAAI,UAAU,OAAO;AAErB,IAAI,QAAQ,uBAAO,OAAO,IAAI;AAE9B,SAAS,QAAQ,SAAS,UAAU;AACnC,MAAI,OAAO,WAAW,QAAQ,GAAG;AAChC,WAAO,QAAQ,SAAS,QAAQ;AAAA,EACjC;AACA,SAAO;AACR;AAEA,YAAY,UAAU,SAAUC,OAAM,UAAU;AAC/C,EAAAA,QAAO,QAAQA,KAAI;AAEnB,SAAO,KAAKA,KAAI,EAAE,KAAK,SAAU,OAAO;AACvC,QAAI,OAAO,MAAMA,KAAI;AAErB,QAAI,QAAQ,KAAK,MAAM,QAAQ,MAAM,MAAM,MAAM,QAAQ,GAAG;AAC3D,aAAO,QAAQ,KAAK,SAAS,QAAQ;AAAA,IACtC;AAEA,WAAO,SAASA,KAAI,EAAE,KAAK,SAAU,MAAM;AAC1C,YAAMA,KAAI,IAAI;AAAA,QACb,OAAO,MAAM;AAAA,QACb,SAAS;AAAA,MACV;AAEA,aAAO,QAAQ,MAAM,QAAQ;AAAA,IAC9B,CAAC;AAAA,EACF,CAAC,EAAE,MAAM,SAAU,KAAK;AACvB,UAAMA,KAAI,IAAI;AACd,WAAO,QAAQ,OAAO,GAAG;AAAA,EAC1B,CAAC;AACF;AAEA,YAAY,QAAQ,OAAO,SAAUA,OAAM,UAAU;AACpD,EAAAA,QAAO,QAAQA,KAAI;AAEnB,MAAI;AACH,QAAI,QAAQ,GAAG,SAASA,KAAI;AAC5B,QAAI,OAAO,MAAMA,KAAI;AAErB,QAAI,QAAQ,KAAK,MAAM,QAAQ,MAAM,MAAM,MAAM,QAAQ,GAAG;AAC3D,aAAO,QAAQ,KAAK,SAAS,QAAQ;AAAA,IACtC;AAEA,QAAI,OAAO,GAAG,aAAaA,KAAI;AAE/B,UAAMA,KAAI,IAAI;AAAA,MACb,OAAO,MAAM;AAAA,MACb,SAAS;AAAA,IACV;AAEA,WAAO,QAAQ,MAAM,QAAQ;AAAA,EAC9B,SAAS,KAAK;AACb,UAAMA,KAAI,IAAI;AACd,UAAM;AAAA,EACP;AAED;AAEA,YAAY,QAAQ,MAAM,SAAUA,OAAM,UAAU;AACnD,EAAAA,QAAO,QAAQA,KAAI;AACnB,MAAI,MAAMA,KAAI,GAAG;AAChB,WAAO,QAAQ,MAAMA,KAAI,EAAE,SAAS,QAAQ;AAAA,EAC7C;AACA,SAAO;AACR;AAEA,YAAY,QAAQ,QAAQ,WAAY;AACvC,UAAQ,uBAAO,OAAO,IAAI;AAC3B;AAEA,IAAI,mBAAmB,YAAY;AAEnC,IAAM,mBAAmB;AACzB,IAAM,sBAAsB;AAC5B,IAAM,qBAAqB;AAE3B,SAAS,QAAQ,KAAK;AACpB,SAAO,iBAAiB,KAAK,GAAG;AAClC;AAEA,SAAS,SAAS,KAAK;AACrB,MAAI,oBAAoB,KAAK,GAAG,GAAG;AAEjC,WAAO,OAAO,KAAK,IAAI,MAAM,EAAE,GAAG,QAAQ,EAAE,SAAS;AAAA,EACvD;AAEA,MAAI,mBAAmB,KAAK,GAAG,GAAG;AAEhC,WAAO,mBAAmB,IAAI,MAAM,EAAE,CAAC;AAAA,EACzC;AAGA,SAAO,mBAAmB,IAAI,MAAM,EAAE,CAAC;AACzC;AAEA,IAAI,UAAU;AAAA,EACZ;AAAA,EACA;AACF;AAEA,IAAM,YAAY;AAClB,IAAM,YAAY;AAElB,IAAI,gBAAgB,SAAS,YAAY,UAAU;AACjD,MAAI,UAAU,QAAQ,QAAQ,GAAG;AAC/B,WAAO,UAAU,SAAS,QAAQ;AAAA,EACpC;AAEA,SAAO,UAAU,UAAU,OAAO;AACpC;AAGA,IAAM,cAAc;AAGpB,IAAM,EAAE,UAAU,IAAI;AAEtB,IAAI,oBAAoB,SAAS,gBAAgB,QAAQ,QAAQ,YAAY,MAAM;AACjF,QAAM,aAAa,CAAC;AACpB,MAAI,QAAQ,CAAC;AAEb,SAAO,KAAK,UAAQ;AAClB,QAAI;AACJ,QAAI,KAAK,SAAS,UAAU;AAC1B,UAAI,KAAK,SAAS;AAChB,eAAO,YAAY,QAAQ,MAAM,YAAY,IAAI;AAAA,eAC1C,KAAK,SAAS;AACrB,eAAO,aAAa,QAAQ,MAAM,YAAY,IAAI;AAAA,IACtD;AAEA,QAAI,MAAM;AACR,UAAI,MAAM,QAAQ;AAChB,mBAAW,KAAK;AAAA,UACd,MAAM;AAAA,UACN;AAAA,UACA,YAAY,CAAC,GAAG,UAAU;AAAA,UAC1B;AAAA,QACF,CAAC;AACD,gBAAQ,CAAC;AAAA,MACX;AACA,iBAAW,KAAK,IAAI;AAAA,IACtB;AAAO,YAAM,KAAK,IAAI;AAAA,EACxB,CAAC;AAED,MAAI,MAAM,QAAQ;AAChB,eAAW,KAAK;AAAA,MACd,MAAM;AAAA,MACN;AAAA,MACA,YAAY,CAAC,GAAG,UAAU;AAAA,MAC1B;AAAA,IACF,CAAC;AAAA,EACH;AAEA,SAAO;AACT;AAEA,SAAS,aAAa,QAAQ,QAAQ,YAAY,MAAM;AACtD,MAAI,OAAO,KAAK,GAAG;AACjB,WAAO,OAAO,KAAK,8CAA8C;AAAA,MAC/D,MAAM;AAAA,IACR,CAAC;AAAA,EACH;AACA,SAAO;AAAA,IACL,MAAM;AAAA,IACN,MAAM;AAAA,IACN,YAAY,CAAC,GAAG,UAAU;AAAA,IAC1B;AAAA,EACF;AACF;AAEA,SAAS,YAAY,QAAQ,QAAQ,YAAY,MAAM;AA5bvD;AA6bE,MAAI,OAAO,OAAO,KAAK;AAGvB,MAAI,MAAM;AACR,OAAG;AACD,UACE,KAAK,SAAS,aACb,KAAK,SAAS,YAAY,KAAK,SAAS,UACzC;AACA,eAAO,KAAK,KAAK;AACjB;AAAA,MACF;AAEA;AAAA,IACF,SAAS;AAAA,EACX;AAIA,MAAI,MAAM;AACR,OAAG;AACD,UACE,KAAK,SAAS,aACb,KAAK,SAAS,aACZ,KAAK,SAAS,aAAc,KAAK,SAAS,WAAW,CAAC,KAAK,QAC9D;AACA,eAAO,KAAK,KAAK;AACjB;AAAA,MACF;AAEA,aAAO,OAAO;AAAA,QACZ;AAAA,QACA,EAAE,MAAM,OAAO;AAAA,MACjB;AAAA,IACF,SAAS;AAAA,EACX;AAEA,MAAI,OAAO,OAAO;AAChB,WAAO,OAAO;AAAA,MACZ;AAAA,MAEA,EAAE,MAAM,OAAO;AAAA,IACjB;AAAA,EACF;AAEA,QAAM,SAAS,YAAY,OAAO,MAAM,EAAE;AAC1C,QAAM,OAAO;AAAA,IACX,MAAM;AAAA,IACN,KAAK;AAAA,IACL,SAAS;AAAA,IACT,MAAM;AAAA,IACN,YAAY,CAAC,GAAG,UAAU;AAAA,IAC1B;AAAA,EACF;AAEA,MAAI;AACJ,MAAI;AACJ,MAAI;AAEJ,WAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACtC,UAAM,OAAO,OAAO,CAAC;AAErB,QAAI,KAAK,SAAS,WAAW,KAAK,SAAS;AAAW;AAEtD,QAAI,KAAK,SAAS,UAAU;AAC1B,UAAI,KAAK,KAAK;AACZ,eAAO,OAAO,KAAK,sBAAsB,OAAO,SAAS,CAAC,KAAK;AAAA,UAC7D,MAAM;AAAA,QACR,CAAC;AAAA,MACH;AAEA,UAAI,CAAC,KAAK,OAAO;AACf,eAAO,OAAO,KAAK,0BAA0B,OAAO,SAAS,CAAC,KAAK;AAAA,UACjE,MAAM;AAAA,QACR,CAAC;AAAA,MACH;AAEA,WAAK,MAAM,KAAK;AAChB,WAAK,UAAU,UAAU,IAAI;AAC7B;AAAA,IACF;AAEA,QAAI,KAAK,SAAS,cAAc,SAAS,KAAK,KAAK,KAAK,GAAG;AACzD,UAAI,KAAK,KAAK;AACZ,eAAO,OAAO,KAAK,sBAAsB,OAAO,SAAS,CAAC,KAAK;AAAA,UAC7D,MAAM;AAAA,QACR,CAAC;AAAA,MACH;AAEA,UAAI,GAAC,gBAAK,UAAL,mBAAa,OAAb,mBAAiB,QAAO;AAC3B,eAAO,OAAO,KAAK,0BAA0B,OAAO,SAAS,CAAC,KAAK;AAAA,UACjE,MAAM;AAAA,QACR,CAAC;AAAA,MACH;AAEA,WAAK,MAAM,KAAK,MAAM,CAAC,EAAE;AACzB,WAAK,UAAU,UAAU,IAAI;AAC7B;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,KAAK;AACb,aAAO,OAAO,KAAK,0BAA0B,OAAO,SAAS,CAAC,KAAK;AAAA,QACjE,MAAM;AAAA,MACR,CAAC;AAAA,IACH;AAEA,SACG,KAAK,SAAS,UAAU,KAAK,SAAS,eACvC,WAAW,KAAK,KAAK,KAAK,GAC1B;AACA,UAAI,OAAO,UAAU,aAAa;AAChC,eAAO,OAAO,KAAK,uBAAuB,OAAO,SAAS,CAAC,KAAK;AAAA,UAC9D,MAAM;AAAA,QACR,CAAC;AAAA,MACH;AAEA,UAAI,OAAO,aAAa,aAAa;AACnC,eAAO,OAAO;AAAA,UACZ,wDAAwD,OAAO,SAAS,CAAC;AAAA,UACzE;AAAA,YACE,MAAM;AAAA,UACR;AAAA,QACF;AAAA,MACF;AAEA,UAAI,KAAK,OAAO;AACd,gBAAQ,UAAU,KAAK,KAAK;AAAA,MAC9B,OAAO;AACL,gBAAQ;AAAA,MACV;AAEA;AAAA,IACF;AAEA,QAAI,KAAK,SAAS,cAAc,cAAc,KAAK,KAAK,KAAK,GAAG;AAC9D,UAAI,OAAO,aAAa,aAAa;AACnC,eAAO,OAAO;AAAA,UACZ,mCAAmC,OAAO,SAAS,CAAC;AAAA,UACpD;AAAA,YACE,MAAM;AAAA,UACR;AAAA,QACF;AAAA,MACF;AAEA,iBAAW,UAAU,KAAK,KAAK;AAE/B;AAAA,IACF;AAEA,YAAQ,UAAU,OAAO,MAAM,CAAC,CAAC;AACjC;AAAA,EACF;AAEA,MAAI,CAAC,KAAK,KAAK;AACb,WAAO,OAAO,KAAK,0BAA0B,OAAO,SAAS,CAAC,KAAK;AAAA,MACjE,MAAM;AAAA,IACR,CAAC;AAAA,EACH;AAEA,MACE,OAAO,UAAU,eACjB,OAAO,UAAU,eACjB,OAAO,aAAa,aACpB;AACA,SAAK,WAAW,KAAK;AAAA,MACnB;AAAA,MACA;AAAA,MACA;AAAA,IACF,CAAC;AAAA,EACH;AAEA,SAAO;AACT;AAGA,IAAM,SAAS,YAAAD;AAGf,IAAI;AAEJ,IAAI,mBAAmB,SAAS,eAC9B,QACA,SACA,UACA,SACA,SACA;AAvnBF;AAwnBE,QAAM,EAAE,QAAQ,IAAI;AACpB,QAAM,MAAM,OAAO,QAAQ,QAAQ;AAEnC,QAAM,aAAa,CAAC;AAGpB,MAAI,QAAQ,QAAQ;AAClB,QAAI,CAAC,SAAS;AAEZ,UAAI;AACF,kBAAU,UAAU,SAAS;AAAA,MAC/B,QAAQ;AAAA,MAAC;AAAA,IACX;AACA,QAAI;AACF,aAAO,WAAW,SAAS,SAAS,UAAU,SAAS,CAAC,OAAO,CAAC;AAAA,EACpE;AAGA,OAAI,YAAO,KAAK,WAAZ,mBAAoB,OAAO;AAC7B,eAAW,KAAK,OAAO,KAAK,OAAO,KAAK;AAAA,EAC1C;AAGA,MAAI,OAAO,KAAK;AAAQ,eAAW,KAAK,OAAO,KAAK,MAAM;AAE1D,aAAW,KAAK,IAAI;AAEpB,SAAO,WAAW,SAAS,SAAS,UAAU,SAAS,UAAU;AACnE;AAEA,SAAS,WAAW,SAAS,SAAS,UAAU,SAAS,SAASL,QAAO;AACvE,MAAI,CAACA;AAAO,IAAAA,SAAQ;AACpB,SAAO,QAAQ,OAAO,EACnB,QAAQ,SAAS;AAAA,IAChB,MAAM;AAAA,IACN,QAAQ,QAAQA,MAAK;AAAA,EACvB,CAAC,EACA,MAAM,SAAO;AAEZ,IAAAA;AAEA,QAAIA,WAAU,QAAQ;AAAQ,YAAM;AACpC,WAAO,WAAW,SAAS,SAAS,UAAU,SAAS,SAASA,MAAK;AAAA,EACvE,CAAC;AACL;AAEA,IAAM,SAAS,YAAAK;AAEf,IAAM,UAAU;AAChB,IAAME,mBAAkB;AACxB,IAAMC,kBAAiB;AACvB,IAAM,cAAc,CAAC,OAAO;AAC5B,IAAMC,uBAAsB;AAE5B,eAAe,cACb,QACA,QACA,SACA,OACA,YACA,MACA,SACA;AACA,QAAM,aAAaF,iBAAgB,QAAQ,QAAQ,YAAY,IAAI;AAEnE,aAAW,QAAQ,YAAY;AAC7B,QAAI,KAAK,SAAS,YAAY,CAAC,iBAAiB,KAAK,GAAG,GAAG;AACzD;AAAA,IACF;AAEA,QAAI,QAAQ,UAAU,CAAC,QAAQ,OAAO,KAAK,GAAG,GAAG;AAE/C;AAAA,IACF;AAEA,UAAM,gBAAgB,QAAQ,MAAM,SAAS,OAAO,OAAO;AAAA,EAC7D;AAEA,MAAI;AACJ,QAAM,UAAU,CAAC;AACjB,QAAM,SAAS,CAAC;AAEhB,WAAS,cAAc,MAAM;AAC3B,QAAI,CAAC;AAAS,gBAAU;AAAA,aAGtB,KAAK,KAAK,OAAO,YAAY,MAAM,QAAQ,KAAK,OAAO,YAAY,GACnE;AACA,YAAM,KAAK,KAAK;AAAA,QACd;AAAA,IACJ,KAAK,KAAK,MAAM,iBAAiB,KAAK,KAAK,OAAO,MAAM,IAAI;AAAA,IAC5D,QAAQ,KAAK,MAAM,iBAAiB,QAAQ,KAAK,OAAO,MAAM,IAAI;AAAA,MAChE;AAAA,IACF;AAAA,EACF;AAGA,aAAW,QAAQ,UAAQ;AACzB,QAAI,KAAK,SAAS;AAAW,oBAAc,IAAI;AAAA,aACtC,KAAK,SAAS,UAAU;AAC/B,UAAI,KAAK,UAAU;AACjB,aAAK,SAAS,QAAQ,CAAC,OAAOP,WAAU;AACtC,cAAI,MAAM,SAAS;AAAU,oBAAQ,KAAK,KAAK;AAAA,mBACtC,MAAM,SAAS;AAAW,0BAAc,KAAK;AAAA;AACjD,mBAAO,KAAK,KAAK;AAEtB,cAAIA,WAAU;AAAG,kBAAM,SAAS;AAAA,QAClC,CAAC;AAAA,MACH;AAAO,gBAAQ,KAAK,IAAI;AAAA,IAC1B,WAAW,KAAK,SAAS,SAAS;AAChC,aAAO,KAAK,IAAI;AAAA,IAClB;AAAA,EACF,CAAC;AAED,SAAO,UAAU,CAAC,SAAS,GAAG,QAAQ,OAAO,MAAM,CAAC,IAAI,QAAQ,OAAO,MAAM;AAC/E;AAEA,eAAe,gBAAgB,QAAQ,MAAM,SAAS,OAAO,SAAS;AA7uBtE;AA8uBE,MAAI,QAAQ,QAAQ,KAAK,GAAG,GAAG;AAE7B,SAAK,WAAW,MAAM;AAAA,MACpB;AAAA,MACA;AAAA,MACA,KAAK;AAAA,MACL;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAEA;AAAA,EACF,WAAW,QAAQ,QAAQ,KAAK,KAAK,MAAM,EAAE,CAAC,GAAG;AAE/C,UAAM,KAAK,KAAK;AAAA,MACd,qBAAqB,KAAK,GAAG;AAAA,IAC/B;AAAA,EACF;AAEA,QAAM,SAAS,KAAK;AACpB,MAAI;AACJ,OAAI,kBAAO,WAAP,mBAAe,UAAf,mBAAsB,MAAM;AAC9B,iBAAa,OAAO,OAAO,MAAM;AAAA,EACnC;AACA,QAAM,OAAO,aACT,OAAO,QAAQ,OAAO,OAAO,MAAM,IAAI,IACvC,QAAQ;AAEZ,QAAM,QAAQ,CAAC,MAAM,QAAQ,QAAQ,KAAK,KAAK,MAAM,SAAS,MAAM,CAAC,EAAE,KAAK;AAG5E,QAAM,WAAW,MAAM,QAAQ;AAAA,IAC7B,MAAM,IAAI,UAAQ;AAChB,aAAO,CAAC,OAAO,WAAW,IAAI,IAC1B,YAAY,IAAI,IAChB;AAAA,IACN,CAAC;AAAA,EACH;AAGA,WAAS,QAAQ,UAAQ;AACvB,WAAO,SAAS,KAAK;AAAA,MACnB,MAAM;AAAA,MACN,QAAQ;AAAA,MACR;AAAA,MACA,QAAQ;AAAA,IACV,CAAC;AAAA,EACH,CAAC;AAED,QAAM,kBAAkB,MAAM,QAAQ;AAAA,IACpC,SAAS,IAAI,UAAQ;AACnB,aAAO,kBAAkB,QAAQ,MAAM,MAAM,SAAS,OAAO,OAAO;AAAA,IACtE,CAAC;AAAA,EACH;AAIA,OAAK,WAAW,gBAAgB,KAAK,EAAE,OAAO,OAAK,CAAC,CAAC,CAAC;AACxD;AAEA,eAAe,kBACb,QACA,MACA,UACA,SACA,OACA,SACA;AAjzBF;AAkzBE,QAAM,SAAS,KAAK;AACpB,QAAM,EAAE,YAAY,KAAK,IAAI;AAC7B,QAAM,wBAAwB,WAC3B;AAAA,IAAI,eACHS,qBAAoB,UAAU,OAAO,UAAU,OAAO,UAAU,QAAQ;AAAA,EAC1E,EACC,KAAK,GAAG;AAEX,MAAI,QAAQ,gBAAgB;AAE1B,SAAI,WAAM,cAAc,QAAQ,MAA5B,mBAAgC,wBAAwB;AAC1D;AAAA,IACF;AAGA,QAAI,CAAC,MAAM,cAAc,QAAQ,GAAG;AAClC,YAAM,cAAc,QAAQ,IAAI,CAAC;AAAA,IACnC;AACA,UAAM,cAAc,QAAQ,EAAE,qBAAqB,IAAI;AAAA,EACzD;AAEA,MAAI,KAAK,SAAS,QAAQ,GAAG;AAC3B;AAAA,EACF;AAEA,QAAM,UAAU,MAAM,QAAQ,KAAK,UAAU,OAAO;AAEpD,MAAI,QAAQ,KAAK,MAAM,MAAM,QAAQ,aAAa;AAChD,WAAO,KAAK,GAAG,QAAQ,aAAa,EAAE,MAAM,OAAO,CAAC;AACpD;AAAA,EACF;AAGA,MACE,QAAQ,oBACR,WAAM,UAAU,OAAO,MAAvB,mBAA2B,yBAC3B;AACA;AAAA,EACF;AAEA,QAAM,iBAAiB,MAAMD;AAAA,IAC3B;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAEA,QAAM,SAAS,eAAe;AAC9B,SAAO,WAAW,OAAO,SAAS,OAAO,eAAe,QAAQ;AAEhE,MAAI,QAAQ,gBAAgB;AAC1B,UAAM,YAAY,OAAO,KAAK,WAAS;AACrC,aAAO,MAAM,SAAS,YAAY,MAAM,SAAS;AAAA,IACnD,CAAC;AACD,QAAI,CAAC,WAAW;AAEd,UAAI,CAAC,MAAM,UAAU,OAAO,GAAG;AAC7B,cAAM,UAAU,OAAO,IAAI,CAAC;AAAA,MAC9B;AAEA,YAAM,UAAU,OAAO,EAAE,qBAAqB,IAAI;AAAA,IACpD;AAAA,EACF;AAGA,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,CAAC,GAAG,MAAM,QAAQ;AAAA,IAClB;AAAA,EACF;AACF;AAEA,SAAS,iBAAiB,KAAK;AAE7B,MAAI,qBAAqB,KAAK,GAAG,GAAG;AAClC,WAAO;AAAA,EACT;AAiBA,SAAO;AACT;AAEA,IAAI,gBAAgB;AAGpB,IAAM,OAAO,YAAAH;AAGb,IAAMK,mBAAkB;AACxB,IAAMC,aAAY;AAClB,IAAMC,eAAc;AACpB,IAAMC,eAAc;AACpB,IAAM,cAAc;AACpB,IAAM,YAAY,CAAC,OAAO;AAE1B,SAAS,SAAS,SAAS;AACzB,YAAU;AAAA,IACR,MAAM,QAAQ,IAAI;AAAA,IAClB,MAAM,CAAC;AAAA,IACP,gBAAgB;AAAA,IAChB,SAAS;AAAA,IACT,MAAMA;AAAA,IACN,SAAS,CAAC;AAAA,IACV,uBAAuB,CAAC;AAAA,IACxB,aAAa;AAAA,IACb,GAAG;AAAA,EACL;AAEA,UAAQ,OAAO,KAAK,QAAQ,QAAQ,IAAI;AAGxC,MAAI,OAAO,QAAQ,SAAS;AAAU,YAAQ,OAAO,CAAC,QAAQ,IAAI;AAElE,MAAI,CAAC,MAAM,QAAQ,QAAQ,IAAI;AAAG,YAAQ,OAAO,CAAC;AAElD,UAAQ,OAAO,QAAQ,KAAK,IAAI,OAAK,KAAK,QAAQ,QAAQ,MAAM,CAAC,CAAC;AAElE,SAAO;AAAA,IACL,eAAe;AAAA,IACf,MAAM,KAAK,QAAQ,EAAE,QAAQ,QAAQ,QAAQ,GAAG;AA57BpD;AA67BM,YAAM,QAAQ;AAAA,QACZ,eAAe,CAAC;AAAA,QAChB,WAAW,CAAC;AAAA,MACd;AAEA,WAAI,kBAAO,WAAP,mBAAe,UAAf,mBAAsB,MAAM;AAC9B,cAAM,cAAc,OAAO,OAAO,MAAM,IAAI,IAAI,CAAC;AAAA,MACnD;AAEA,UAAI,QAAQ,WAAW,CAAC,MAAM,QAAQ,QAAQ,OAAO,GAAG;AACtD,cAAM,IAAI,MAAM,iCAAiC;AAAA,MACnD;AAEA,YAAM,SAAS,MAAM;AAAA,QACnB;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA,CAAC;AAAA,QACD,CAAC;AAAA,QACD;AAAA,MACF;AAEA,MAAAF,WAAU,MAAM;AAChB,MAAAD,iBAAgB,QAAQ,MAAM;AAC9B,MAAAE,aAAY,QAAQ,MAAM;AAAA,IAC5B;AAAA,EACF;AACF;AAEA,SAAS,UAAU;AAEnB,IAAI,gBAAgB;AAEpB,IAAI,QAAqB,wBAAwB,aAAa;AAE9D,IAAI,UAAuB,iBAAiB;AAAA,EAC1C,WAAW;AAAA,EACX,SAAS;AACX,GAAG,CAAC,aAAa,CAAC;",
  "names": ["__cjs_fileURLToPath", "__cjs_dirname", "require", "__cjs_createRequire", "base64EncodedConditionalImport", "index", "resolve", "i", "ret", "require$$0__default", "require$$0", "path", "parseStatements", "processContent", "formatImportPrelude", "applyConditions", "applyRaws", "applyStyles", "loadContent"]
}
